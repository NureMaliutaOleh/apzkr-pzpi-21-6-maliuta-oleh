Міністерство освіти та науки України
Харківський національний університет радіоелектроніки

Факультет комп’ютерних наук

Кафедра програмної інженерії

КУРСОВА РОБОТА
ПОЯСНЮВАЛЬНА ЗАПИСКА
з навчальної дисципліни «Архітектура програмного забезпечення»
Тема роботи: Програмна система для автоматизованого управління вікнами, вентиляцією та дверми "SmartInlet"

Студент гр. ПЗПІ-21-6		__________________ Малюта О.В.
                                       		(підпис)
Керівник роботи 			___________________ ст.викл. Сокорчук І.П.
                             			(підпис)
Роботу захищено «13» червня 2024 р.
з оцінкою _________________________
Комісія: 				___________________ доц. Лещинський В.О.
(підпис)
___________________ доц. Лещинська І.О.
(підпис)
___________________ ст.викл. Сокорчук І.П.
(підпис)


Харків 2024 р.
Аркуш завдання

Харківський національний університет радіоелектроніки

Факультет комп’ютерних наук          Кафедра програмної інженерії_____________
Спеціальність 121 – Інженерія програмного забезпечення______________________
Курс __________3__________ Семестр _________________6___________________
Навчальна дисципліна Архітектура програмного забезпечення_________________

ЗАВДАННЯ
НА КУРСОВУ РОБОТУ СТУДЕНТОВІ

________________________Малюті Олегу Вадимовичу_______________________
1. Тема роботи: «Програмна система для автоматизованого управління вікнами, вентиляцією та дверми "SmartInlet"»_______________________________________
2. Термін узгодження завдання курсової роботи «18» березня 2024 р.
3. Термін здачі студентом закінченої роботи «6» червня 2024 р.
4. Вихідні дані до проєкту (роботи): В програмній системі передбачити: реєстрація та авторизація користувачів, наявність прав доступу для користувачів, групування користувачів в організації. Розробити взаємодію з IoT пристроями. Операційна система Windows 11, СУБД MS SQL, середовище розробки Microsoft Visual Studio 2022 та Visual Studio Code_____________________________________
5. Зміст пояснювальної записки (перелік питань, що належить розробити)
вступ, аналіз предметної області, постановка задачі, проєктування програмного проєкту, структура бази даних, кодування програмного проєкту, опис розробленої програмної системи, висновки, перелік посилань, додатки______________________
6. Перелік графічного матеріалу (з точним зазначенням обов’язкових креслень)
схема бази даних, діаграма варіантів використання, діаграма розгортання, інтерфейс головної сторінки______________________________________________ 
КАЛЕНДАРНИЙ ПЛАН
№	Назва етапів курсової роботи	Термін виконання етапів роботи	Примітка
1	Функціональна специфікація програмного проєкту	21.03.2024	виконано
2	Проєктування програмного проєкту	04.04.2024	виконано
3	Кодування програмного проєкту	25.04.2024	виконано
4	Оформлення пояснювальної записки	16.05.2024	виконано
5	Захист курсової роботи	06.06.2024	виконано

Дата видачі завдання «15» квітня 2024 р.

Керівник 						______________ ст.викл. Сокорчук І.П.
(підпис)

Завдання прийняв до виконання		______________ Малюта О.В.
ст.гр. ПЗПІ-21-6					(підпис)
 
РЕФЕРАТ
 
 Пояснювальна записка до курсової роботи: 54 сторінки, 4 рисунки, 5 джерел.
ПЛАТФОРМА ASP.NET, ФРЕЙМВОРК REACT.JS, МІКРОКОНТРОЛЕР, ESP-32, ІНТЕРНЕТ РЕЧЕЙ, ВІКНО, ВЕНТИЛЯЦІЯ, ДВЕРІ, СЕНСОР, ПОВІТРЯ, ТЕМПЕРАТУРА.
Метою роботи  є розробка програмної системи для автоматизованого управління вікнами, вентиляцією та дверми "SmartInlet".
Методи розробки базуються на використанні середи розробки  Microsoft Visual Studio 2022 із використанням платформи ASP.NET, фреймворку React.js. 
В результаті отримана програмна система під назвою "SmartInlet", яка дозволяє дистанційно та автоматично керувати пристроями для відкриття та закриття таких об'єктів, як вікна, двері та вентиляції за допомогою датчиків повітря та температури.

ЗМІСТ

РЕФЕРАТ	4
ЗМІСТ	5
ВСТУП	6
1	АНАЛІЗ ПРЕДМЕТНОЇ ОБЛАСТІ	7
1.1 Загальний аналіз	7
1.2 Існуючі аналоги	7
1.3 Потреби клієнтів або ринку	8
2	ПОСТАНОВКА ЗАДАЧІ	10
2.1 Окреслення концепції	10
2.2 Головна функціональність	10
2.3 Рамки первиного випуску	11
2.4 Рамки наступних випусків	12
2.5 Обмеження та винятки	13
2.6 Робоче середовище	13
3	АРХІТЕКТУРА ТА ПРОЕКТУВАННЯ СИСТЕМИ	15
3.1 Загальна архітектура системи	15
3.2 Побудова діаграми розгортання	15
3.3 Архітектура серверної частини системи	16
3.4 Побудова діаграми прецендентів	17
3.5 Побудова ER-діаграми	19
3.6 Побудова діаграми пакетів	20
4	РЕАЛІЗАЦІЯ ПРОГРАМНОЇ СИСТЕМИ	21
ВИСНОВКИ	27
ПЕРЕЛІК ДЖЕРЕЛ ПОСИЛАННЯ	28
ДОДАТОК А	29
А.1 Код запуску серверної частини	29
А.2 Код сервісу для відправлення електронних повідомлень	31
А.3 Код ORM класу для роботи з базою даних	33
А.4 Код класу з функціями для хешування та перевірки хешованих паролів.	35
А.5 Код контролеру для роботи з пристроями та датчиками	37
ДОДАТОК Б	54
 
ВСТУП

Сучасний світ висуває високі вимоги до комфорту, енергоефективності та безпеки житлових і комерційних приміщень. Технологічний прогрес у сфері інтернету речей і автоматизації створює нові можливості для покращення якості життя та оптимізації використання ресурсів. У контексті цього прогресу, з’являється потреба в інтелектуальних системах, які можуть автоматично керувати основними аспектами будівель, такими як вікна, вентиляція та двері.
Ручне управління цими системами часто є незручним та неефективним. Наприклад, постійне відкривання і закривання вікон для регулювання температури і провітрювання може бути трудомістким, а залишені відчиненими вікна чи двері можуть становити загрозу безпеці. Традиційні вентиляційні системи, які не враховують зовнішні умови або присутність людей у приміщенні, також можуть бути енерговитратними.
Існуючі системи автоматизації зазвичай або занадто дорогі, або складні у впровадженні та використанні, що робить їх недоступними для широкого кола користувачів. Тому виникла необхідність у створенні доступної, легкої в експлуатації та інтуїтивно зрозумілої системи управління, яка б інтегрувала управління вікнами, вентиляцією та дверима в одному рішенні.
Метою цієї курсової роботи є розробка системи «SmartInlet», яка має на меті вирішити ці проблеми, забезпечивши зручний та ефективний спосіб управління кліматом і безпекою приміщень за допомогою сучасних технологій. Використовуючи датчики, алгоритми машинного навчання та інтерфейси користувача, система «SmartInlet» наддасть користувачам можливість автоматично регулювати стан вікон, вентиляції та дверей залежно від зовнішніх умов, внутрішньої температури, стану повітря, що впливають на комфорт і безпеку.
 
1	АНАЛІЗ ПРЕДМЕТНОЇ ОБЛАСТІ
1.1 Загальний аналіз

Ринок розумних будинків і автоматизованих систем управління швидко розвивається, створюючи нові бізнес-можливості для інноваційних продуктів, таких як «SmartInlet». Згідно з прогнозами аналітиків, світовий ринок інтернету речей (IoT) у сфері розумних будинків досягне значного зростання протягом наступних кількох років. Це зростання обумовлено збільшенням попиту на зручність, безпеку та енергоефективність у житлових і комерційних приміщеннях.
Основні бізнес-можливості для системи «SmartInlet» включають:
- Зменшення енергоспоживання: Завдяки автоматичному регулюванню вікон, вентиляції та дверей, система «SmartInlet» допомагає знизити витрати на опалення та кондиціонування, що стає все більш важливим у контексті підвищення цін на енергію та необхідності зменшення вуглецевого сліду.
- Підвищення комфорту та безпеки: Система забезпечує оптимальний мікроклімат у приміщеннях, автоматично відкриваючи або закриваючи вікна та вентиляційні отвори відповідно до температури, вологості та якості повітря. Крім того, автоматизоване управління дверима підвищує рівень безпеки, знижуючи ризики, пов’язані з незачиненими дверима.
- Розширення ринку через співпрацю: Виробники вікон, дверей та вентиляційних систем можуть інтегрувати «SmartInlet» у свої продукти, що дозволить розширити ринок збуту та збільшити доходи.

1.2 Існуючі аналоги

На ринку існує декілька аналогів, які пропонують подібні функції управління окремими аспектами розумного будинку. Наприклад, Ecobee - компанія, яка спеціалізується на розумних термостатах, які також можуть інтегруватися з датчиками якості повітря та вологості. Проте, Ecobee не пропонує комплексного рішення для управління вікнами та дверима. Також у виді аналогу можна привести Somfy, який являється виробником систем автоматизації для вікон та жалюзі, який також пропонує рішення для розумного будинку. Однак, їхні системи частіше використовуються в контексті управління жалюзі та шторами, ніж для комплексного контролю вікон, вентиляції та дверей.
«SmartInlet» відрізняється від аналогів своєю цілісним підходом до управління вікнами, вентиляцією та дверима, забезпечуючи користувачам єдине рішення для підтримання оптимального клімату і безпеки в їхніх приміщеннях. Це створює унікальну бізнес-можливість для виходу на ринок з інноваційним продуктом, який задовольняє потреби сучасних споживачів.

1.3 Потреби клієнтів або ринку

Основні потреби клієнтів та ринку включають:
- Енергоефективність: споживачі прагнуть зменшити витрати на енергію, шукаючи рішення, які автоматично оптимізують використання опалення, кондиціонування та вентиляції. «SmartInlet» дозволяє знизити енергоспоживання за рахунок автоматичного регулювання вікон та вентиляції, відповідно до зовнішніх умов і внутрішніх параметрів.
- Комфорт: сучасні користувачі бажають підтримувати оптимальний мікроклімат у своїх приміщеннях без постійної необхідності втручатися у процес управління. «SmartInlet» забезпечує комфортний рівень температури, вологості та якості повітря за допомогою автоматизованих налаштувань, враховуючи присутність людей у приміщенні та їхні індивідуальні вподобання.
- Безпека: безпека є одним із пріоритетів для власників будинків і комерційних приміщень. Клієнти шукають рішення, що забезпечують захист від зломів, а також попереджають про відкриті вікна або двері. «SmartInlet» пропонує інтегровані функції безпеки, такі як автоматичне закриття вікон та дверей при відсутності користувачів або у разі погіршення погодних умов.
- Інтеграція з іншими системами: багато користувачів вже мають інші IoT-пристрої і бажають, щоб нові системи були сумісні з їхньою поточною екосистемою. «SmartInlet» розроблена для легкої інтеграції з популярними платформами розумного будинку, що дозволяє створити єдину централізовану систему управління.
- Простота використання: інтуїтивно зрозумілий інтерфейс і легкість налаштувань є важливими аспектами для користувачів, які не завжди мають технічний досвід. «SmartInlet» пропонує простий у використанні застосунок, що дозволяє легко контролювати та налаштовувати систему відповідно до індивідуальних потреб.
- Екологічна свідомість: все більше користувачів прагнуть зменшити свій екологічний слід і шукають рішення, що допомагають досягти цієї мети. «SmartInlet» сприяє зменшенню викидів CO2 завдяки підвищенню енергоефективності будівель і оптимізації використання природних ресурсів.

2	ПОСТАНОВКА ЗАДАЧІ
2.1 Окреслення концепції

Концепція системи «SmartInlet» спрямована на створення інноваційного, зручного та ефективного рішення для автоматизованого управління будинками, яке відповідає сучасним вимогам комфорту, безпеки та екологічності.
Система «SmartInlet» представляє собою комплексне рішення для автоматизованого управління вікнами, вентиляцією та дверима, яке спрямоване на забезпечення оптимального мікроклімату, підвищення енергоефективності та забезпечення безпеки в житлових і комерційних приміщеннях. Концепція системи базується на використанні сучасних технологій інтернету речей (IoT), датчиків і автоматизованого або дистанційного управління пристроями, що займаються контролем вікон, дверей та вентиляцій.

2.2 Головна функціональність

Згідно із потребами потенційних користувачів системи було сформовано список її основних функцій:
MF-1: Реєстрація та авторизація користувачів.
MF-2: Створення груп, додавання та видалення користувачів з груп.
MF-3: Управління правами користувачів у групах.
MF-4: Додавання приладів до груп для подальшого використання.
MF-5: Автоматизоване управління приладами для контролю дверей, вікон та вентиляції за допомогою датчиків стану повітря або температури.
MF-6: Можливість ручного дистанційного управління пристроями контролю дверей, вікон, або дверей.
MF-7: Можливість зміни мови клієнтського застосунку на запропоновані мови: англійську та українську.
MF-8: Можливість зміни теми клієнтського застосунку, серед яких є світла та темна.
MF-9: Адміністрування користувачів (управління правами адміністратора інших користувачів, відправлення електронного листа, видалення користувачів).
MF-10: Адміністрування IoT приладів (реєстрація, блокування, видалення).

2.3 Рамки первиного випуску

Первинний випуск системи «SmartInlet» передбачає створення та інтеграцію кількох ключових компонентів, які забезпечать повноцінну функціональність і зручність використання продукту. Основними компонентами є серверна частина, клієнтська частина, IoT пристрої та мобільний застосунок. Кожен з цих компонентів відіграє важливу роль у забезпеченні стабільної та ефективної роботи системи.
Серверна частина:
- Отримання та подальша обробка запитів на отримання, зміну та обробку даних від клієнтів.
- RESTful API для взаємодії з клієнтом та IoT пристроями.
- Шифрування таких даних, як паролі та інша важлива інформація користувачів для забезпечення їхньої безпеки та конфіденційності.
- Перевірка запитів від IoT пристроїв на їхню дійсність за допомогою токену доступу.
- Реалізація реєстрації та авторизації користувачів з використанням Cookie файлів.
- Функціонал відновлення паролю користувача за електронною адресою.
- Сервіс для відправлення електронних листів на пошту користувача.
- Адміністрування користувачів та приладів.
IoT пристрій:
- Періодичні запити на отримання та подальшої зміни інформації для пристроїв, які призначені для управління вікнами, вентиляцією та дверми.
- Періодична відправлення даних на сервер від датчиків, що вимірюють чистоту повітря або температуру.
Веб застосунок:
- Реєстрація та авторизація користувачів.
- Створення груп, додавання та видалення користувачів з груп.
- Управління правами користувачів у групах.
- Додавання приладів до груп для подальшого використання.
- Налаштування та зміна управління приладами для контролю дверей, вікон та вентиляції.
- Інтерфейс для адміністрування користувачів та приладів.
- Функція вибору теми для застосунку для інтерфейсу користувача, серед яких є світла та темна.
Мобільний застосунок:
- Реалізація функціоналу, схожого з веб застосунком.

2.4 Рамки наступних випусків

Після успішного запуску первинного випуску системи «SmartInlet», планується реалізація кількох наступних випусків, які будуть включати нові функції та вдосконалять існуючі можливості системи.
У подальших випусках програмної системи планується підтримка нових типів датчиків, таких як датчики освітленості, шуму та атмосферного тиску, для більш комплексного моніторингу умов у приміщенні і вдосконалення механізмів управління вікнами, дверима та вентиляцією для підвищення їхньої надійності, швидкості та точності.
Також планується впровадження розширених алгоритмів машинного навчання для більш точного прогнозування умов та адаптації системи до індивідуальних потреб користувачів.

2.5 Обмеження та винятки

Незважаючи на численні переваги системи «SmartInlet», існують певні обмеження та винятки, які слід враховувати під час її впровадження та експлуатації. Ці фактори можуть вплинути на ефективність роботи системи та її здатність задовольняти всі вимоги користувачів:
- Сумісність пристроїв: система може бути несумісною з деякими типами вікон, дверей та вентиляційних систем, особливо якщо вони мають нестандартні розміри або конструкції. Для коректної роботи системи може знадобитися модернізація або заміна таких пристроїв.
- Обмеження датчиків: точність і надійність роботи системи залежать від якості встановлених датчиків. Неточності у роботі датчиків можуть призвести до неправильних рішень системи щодо відкривання/закривання вікон, вентиляції або дверей.
- Інтернет-з'єднання: для повноцінної роботи системи необхідне стабільне підключення до Інтернету. Відсутність або нестабільність з'єднання може обмежити можливість віддаленого управління та отримання даних у реальному часі.

2.6 Робоче середовище

Система передбачає використання інтернет-з'єднання для обміну даними між серверною частиною, клієнтською частиною, мобільним застосунком та IoT пристроєм. Рекомендується стабільне та безпечне з'єднання для забезпечення надійного функціонування та захисту інформації.
Для забезпечення безпеки та конфіденційності даних система використовуватиме шифрування під час передачі даних через мережу. Крім того, будуть впроваджені механізми автентифікації та авторизації для забезпечення контролю доступу.
Система буде сумісною з різними пристроями та платформами, щоб забезпечити максимальну доступність та зручність для користувачів. Застосунок і веб-версія будуть адаптовані для різних роздільних здатностей та екранних розмірів.
Система буде підтримуватися та обслуговуватися з використанням віддалених методів доступу для адміністраторів та технічного персоналу. Планується регулярне оновлення системи для забезпечення безпеки та виправлення можливих помилок.
Система буде оптимально функціонувати у наступному технічному середовищі:
а) Серверна частина:
1) Операційна система: Windows 11.
2) Мова програмування: C#.
3) База даних: Microsoft SQL.
4) ORM для роботи з базами даних: Entity Framework Core.
б) Клієнтська частина:
1) Мова програмування: JavaScript.
2) Фреймворк для Front-end розробки: React.js.
в) Мобільний застосунок:
1) Операційні системи: Android.
2) Мова програмування: Kotlin.
г) IoT пристрій:
1) Мікроконтролер: Raspberry Pi, ESP32 або аналогічний.
2) Мережа: Wi-Fi або Ethernet.
 
3 АРХІТЕКТУРА ТА ПРОЕКТУВАННЯ СИСТЕМИ
3.1 Загальна архітектура системи

Серед технологій для розробки серверної частини було обрано мову програмування C# з використанням .NET 8 та технологію ASP.NET для створення RESTful API для взаємодії з клієнтами та IoT пристроями.
Було використано додаткові пакети та бібліотеки для взаємодії з ASP.NET та Entity Framework Core.
Для даної системи використовується база даних Microsoft SQL Server та в якості ORM було обрано Entity Framework Core так як дана СУБД і ORM найбільше підходять для реалізації клієнт-серверних систем, які використовують С# та ASP.NET. Також було включено підтримку міграцій для зберігання даних при зміні структури БД.
Авторизація користувачів реалізована за допомогою згенерованих ключів, які зберігаються у Cookie файлах.
Для забезпечення безпеки даних користувачів відбувається хешування паролів за допомогою стандарту PBKDF2, після чого отриманий хеш зберігається в базі даних.
В проекті присутня підтримка кодувань UTF-8 та ASCII для забезпечення можливості зберігання та передачі даних на різних мовах та використання більшої кількості спеціальних символів.
У серверній частині увесь час та дати використовуються та зберігаються за UTC стандартом. Це дає можливість отримання локального часу в залежності від часового поясу, що забезпечує інтернаціоналізацію.
Присутня можливість адміністрування користувачів шляхом управління їхніми правами, відправлення електронних листів та видалення користувача, і адміністрування IoT пристрої, що включає отримання інформації про пристрої, управління доступом та можливість їх видалення.

3.2 Побудова діаграми розгортання

Також інформацію про компоненти та розгортання серверної частини можна побачити на UML діаграмі розгортання (див. рис. 3.1).
 
Рисунок 3.1 - UML діаграма розгортання

3.3 Архітектура серверної частини системи

Серверна частина програмної системи «SmartInlet» була створена на платформі ASP.NET Core з використанням .NET 8 та написана на мові програмування С#.
Серверна частина було розроблена за архітектурою Monolithic. Дана архітектура представляє собою підхід до розробки додатків, у якому вони розбиваються на невеликі, незалежні служби, які можуть опрацьовуватися, тестуватися і розгортатися незалежно один від одного і кожна з них має свою незалежну роль та функціонал.
У серверній частині є головний простір імен SmartInlet.Server, який був поділений на інші простори імен, компоненти, яких відповідають за різні частини серверного застосунку: Controllers, Models, Services, Requests, Responses, Tools та Attributes.
- SmartInlet.Server.Controllers зберігає в собі контролери, що являють собою обробники HTTP запитів від клієнтів та IoT пристроїв.
- SmartInlet.Server.Requests зберігає класи для зберігання даних з HTTP запитів.
- SmartInlet.Server.Responses зберігає класи, які представляють собою тіла для відправки відповідей до HTTP запитів.
- SmartInlet.Server.Models зберігає моделі таблиць та міграції для бази даних для взаємодії з Entity Framework Core.
- SmartInlet.Server.Services зберігає інструменти для взаємодії із зовнішніми сервісами, такими як база даних та електронна пошта.
- SmartInlet.Server.Tools зберігає прості класи із функціями для вирішення простих задач як хешування та перевірка паролів або генерація випадкових строк для створення коду доступу.
- SmartInlet.Server.Attributes зберігає різні створені атрибути, наприклад ті, що призначені для перевірки прав користувача перед виконання функції обробки HTTP запитів.

3.4 Побудова діаграми прецендентів

Було створено діаграму прецедентів (див. рис. 3.2), яка була базована на аналізі функціонала,  визначеному у документі «Vision & Scope». При розробці в даній системі було передбачено два типи користувачів: Користувач та Адміністратор.
 
Рисунок 3.2 - UML діаграма прецедентів 

3.5 Побудова ER-діаграми

Для демонстрації структури бази даних була спроектована ER-модель даних (див. рис. 3.3), яка демонструє всі сутності та їхні взаємозв'язки.
 
Рисунок 3.3 - ER модель даних

3.6 Побудова діаграми пакетів

На діаграмі пакетів (див. рис. 3.4) було зображено пакетну структуру програмної системи.

 
Рисунок 3.4 - UML діаграма пакетів

4 РЕАЛІЗАЦІЯ ПРОГРАМНОЇ СИСТЕМИ

Таблиця 1 – Специфікація REST
Метод	Маршрут	Призначення
POST	/api/admin/devices	Реєстрація нового пристрою або датчику.
GET	/api/admin/devices/inlet	Отримання списку пристроїв для контролю вікон, дверей або вентиляції.
GET	/api/admin/devices/air	Отримання списку датчиків повітря.
GET	/api/admin/devices/temp	Отримання списку датчиків температури.
PUT	/api/admin/devices/block	Блокування пристрою або датчика.
DELETE	/api/admin/devices/{deviceId}	Видалення пристрою або датчика.
POST	/api/admin/users/{username}/send-email	Відправлення електронного листа користувачеві.
PUT	/api/admin/users/{username}/rights	Зміна прав адміністрування користувача.
DELETE	/api/admin/users/{username}	Видалення користувача.
POST	/api/devices	Додавання пристрою або датчику до групи.
Продовження таблиці 1
GET	/api/devices/inlet/by-group/{groupName}	Отримання списку «пристроїв управління» в групі.
GET	/api/devices/air/by-group/{groupName}	Отримання списку датчиків повітря в групі.
GET	/api/devices/temp/by-group/{groupName}	Отримання списку датчиків температури в групі.
PUT	/api/devices/{deviceId}	Перейменування пристрою.
DELETE	/api/devices/{deviceId}	Видалення пристрою з групи.
PUT	/api/devices/inlet/{deviceId}/control-type/manual	Змінити тип контролю «пристрою управління» на ручний.
PUT	/api/devices/inlet/{deviceId}/control-type/air	Зробити контроль «пристрою управління» залежним від обраного датчику повітря.
PUT	/api/devices/inlet/{deviceId}/control-type/temp	Зробити контроль «пристрою управління» залежним від обраного датчику температури.
Продовження таблиці 1
PUT	/api/devices/inlet/{deviceId}/air-sensor	Змінити датчик повітря для «пристрою управління».
PUT	/api/devices/inlet/{deviceId}/temp-sensor	Змінити датчик температури для «пристрою управління».
PUT	/api/devices/inlet/{deviceId}/open	Відкрити або закрити «пристрій управління».
PUT	/api/devices/air/{sensorId}/limits	Встановити обмеження показників датчика повітря для закриття та відкриття «пристрою управління».
PUT	/api/devices/temp/{sensorId}/limits	Встановити обмеження показників датчика температури для закриття та відкриття «пристрою управління».
POST	/api/groups	Створити групу.
GET	/api/groups	Показати список існуючих груп.
GET	/api/groups/{groupName}/info	Вивести інформацію про групу.
PUT	/api/groups/{groupName}/info	Змінити інформацію про групу.
Продовження таблиці 1
POST	/api/groups/{groupName}/send-join-offer	Відправи запрошення від групи.
POST	/api/groups/{groupName}/accept-join-offer/{offerId}	Підтвердити запит на вступ до групи від користувача.
GET	/api/groups/{groupName}/sent-join-offers	Показати відправлені запрошення від групи.
GET	/api/groups/{groupName}/received-join-offers	Показати запити на приєднання до групи.
DELETE	/api/groups/{groupName}/cancel-join-offer/{offerId}	Відхилення запиту або запрошення.
GET	/api/groups/{groupName}/members	Показати список учасників групи.
PUT	/api/groups/{groupName}/member/{memberId}	Змінити права учасника групи.
DELETE	/api/groups/{groupName}/member/{memberId}	Видалити учасника групи.
DELETE	/api/groups/{groupName}	Видалити групу або покинути її, передавши права власника іншому.
GET	/api/iot/inlet/{deviceId}/try	Запит від «пристрою управління» на отримання інформації.
GET	/api/iot/air/{sensorId}/try	Відправка показників датчика повітря.
Продовження таблиці 1
GET	/api/iot/temp/{sensorId}/try	Відправка показників датчика температури.
POST	/api/users/sign-up	Зареєструватися.
POST	/api/users/sign-in	Авторизуватися.
GET	/api/users/sign-out	Вийти.
GET	/api/users/check	Перевірка на авторизацію.
GET	/api/users	Отримати список користувачів.
DELETE	/api/users	Видалити свій акаунт.
GET	/api/users/info	Отримати дані про свій акаунт.
PUT	/api/users/info	Змінити дані акаунта.
GET	/api/users/{username}/info	Отримати дані іншого користувача.
PUT	/api/users/password	Змінити пароль.
PUT	/api/users/email	Змінити адресу електронної пошти.
POST	/api/users/reset-password-permission	Отримати дозвіл на перезапис паролю за адресою електронної пошти.
PUT	/api/users/reset-password	Перезаписати пароль.
GET	/api/users/confirm-email/{email}	Підтвердження дії через електронну пошту.
Продовження таблиці 1
POST	/api/users/send-join-offer	Відправити запит на вступ до групи.
POST	/api/users/accept-join-offer/{offerId}	Підтвердити запрошення на вступ до групи.
GET	/api/users/sent-join-offers	Відправлені запити на вступ до груп.
GET	/api/users/received-join-offers	Отримані запрошення від груп.
DELETE	/api/users/cancel-join-offer/{offerId}	Відхилення запиту або запрошення.
 
ВИСНОВКИ

Під час виконання курсової роботи було здобуто практичні навички проектування та створення складних програмних систем, пов’язаними з інтернетом речей, внаслідок чого було розроблено програмну систему, яка призначена для автоматичного або ручного управління вікнами, дверми та вентиляцією в приміщеннях.
Дана система має декілька програмних застосунків, як: серверний, клієнтський і мобільний застосунки, та застосунки IoT для пристроїв управління вікнами, дверми, та вентиляцією і датчиками повітря та температурою.
 
ПЕРЕЛІК ДЖЕРЕЛ ПОСИЛАННЯ

1. React Compiler: Everything You Need to Know. URL: https://dev.to/mjubair/react-compiler-everything-you-need-to-know-51b9 (Дата звернення 10.06.2024).
2. ASP.NET overview. URL: https://learn.microsoft.com/en-us/aspnet/overview (Дата звернення 10.06.2024).
3. .NET Documentation. URL: https://learn.microsoft.com/en-us/dotnet/ (Дата звернення 10.06.2024).
4. Репозиторій у віддаленій системі керування версіями. 
URL: https://github.com/NureMaliutaOleh/apzkr-pzpi-21-6-maliuta-oleh (Дата звернення 10.06.2024).
5. Функціональне тестування серверної частини програмного продукту. 
URL: https://youtu.be/eeuFDqoQePQ (Дата звернення 10.06.2024).
 
ДОДАТОК А
Програмний код серверної частини системи
А.1 Код запуску серверної частини
 
1. using Microsoft.AspNetCore.Authentication.Cookies;
2. using Microsoft.EntityFrameworkCore;
3. using SmartInlet.Server.Services.DB;
4. using SmartInlet.Server.Services.Email;
5. 
6. namespace SmartInlet.Server
7. {
8.     public class Program
9.     {
10.         public static void Main(string[] args)
11.         {
12.             var builder = WebApplication.CreateBuilder(args);
13. 
14.             builder.Services.AddDbContext<DbApp>(options =>
15.             {
16.                 options.UseSqlServer(builder.Configuration["EF:ConnectionString"]);
17.             });
18. 
19.             builder.Services.AddControllers();
20.             builder.Services.AddEndpointsApiExplorer();
21.             builder.Services.AddSwaggerGen();
22.             builder.Services.AddCors();
23. 
24.                                   builder.Services.AddAuthentication(CookieAuthenticationDefaults.AuthenticationScheme)
25.                 .AddCookie();
26. 
27.             builder.Services.AddEmailService(e =>
28.             {
29.                 e.Email = builder.Configuration["Email:EmailAddress"];
30.                 e.SenderName = builder.Configuration["Email:SenderName"];
31.                 e.Password = builder.Configuration["Email:Password"];
32.                 e.Host = builder.Configuration["Email:Host"];
33.                 e.Port = int.Parse(builder.Configuration["Email:Port"]);
34.                 e.EmailTemplatesFolder = builder.Configuration["Email:EmailTemplatesFolder"];
35.             });
36. 
37.             var app = builder.Build();
38. 
39.             using (var scope = app.Services.CreateScope())
40.             {
41.                 var db = scope.ServiceProvider.GetRequiredService<DbApp>();
42. 
43.                 if (!db.Database.CanConnect())
44.                 {
45.                     throw new NotImplementedException("Can not connect to the DB!");
46.                 }
47.             }
48. 
49.             app.UseDefaultFiles();
50.             app.UseStaticFiles();
51. 
52.             if (app.Environment.IsDevelopment())
53.             {
54.                 app.UseSwagger();
55.                 app.UseSwaggerUI();
56.             }
57. 
58.             app.UseHttpsRedirection();
59.             app.UseAuthorization();
60.             app.UseAuthentication();
61.             app.UseCors(builder =>
62.                 builder.AllowCredentials().AllowAnyHeader().AllowAnyMethod().WithOrigins(
63.                     "https://localhost:5173"
64.                 ));
65. 
66.             app.MapControllers();
67.             app.MapFallbackToFile("/index.html");
68. 
69.             app.Run();
70.         }
71.     }
72. }

А.2 Код сервісу для відправлення електронних повідомлень

1. using Microsoft.Extensions.Options;
2. using System.Net;
3. using System.Net.Mail;
4. using System.Text.RegularExpressions;
5. 
6. namespace SmartInlet.Server.Services.Email
7. {
8. 	public class EmailService : IEmailService
9. 	{
10. 		private readonly EmailServiceConfigurationMetadata configuration;
11. 
12. 		private string EmailTemplatesFolder =>
13. 			Path.IsPathRooted(configuration.EmailTemplatesFolder) ?
14. 			configuration.EmailTemplatesFolder :
15. 			Path.Combine(
16. 				Directory.GetCurrentDirectory(),
17. 				configuration.EmailTemplatesFolder);
18. 
19. 		public EmailService(IOptions<EmailServiceConfigurationMetadata> configuration)
20. 		{
21. 			this.configuration = configuration.Value;
22. 		}
23. 
24. 		public async Task SendEmailAsync(
25. 			string email,
26. 			string subject,
27. 			string message,
28. 			bool isHtml = false)
29. 		{
30.             using SmtpClient client = Connect();
31.             using MailMessage mailMessage = new(
32. 				configuration.Email,
33. 				email,
34. 				subject,
35. 				message);
36. 
37.             mailMessage.IsBodyHtml = isHtml;
38.             await client.SendMailAsync(mailMessage);
39.         }
40. 
41. 		public async Task SendEmailUseTemplateAsync(
42. 			string email,
43. 			string templateName,
44. 			Dictionary<string, string>? parameters = null, string? subject = null)
45. 		{
46. 			string templatePath = Path.Combine(EmailTemplatesFolder, templateName);
47. 			if (!File.Exists(templatePath))
48. 			{
49. 				throw new FileNotFoundException(
50. 					$"Template {templateName} not found");
51. 			}
52. 
53. 			string template = File.ReadAllText(templatePath);
54. 			if (parameters != null)
55. 			{
56. 				foreach (var parameter in parameters)
57. 				{
58. 					template = template.Replace(
59. 						$@"{{{{{parameter.Key}}}}}",
60. 						parameter.Value);
61. 				}
62. 			}
63. 
64. 			subject ??= Regex.Match(
65. 				template,
66. 				@"<meta name=""subject"" content=""(.*)""").Groups[1].Value;
67. 
68. 			await SendEmailAsync(email, subject, template, true);
69. 		}
70. 
71. 		private SmtpClient Connect()
72. 		{
73.             SmtpClient smtpClient = new()
74.             {
75.                 Host = configuration.Host,
76.                 Port = configuration.Port,
77.                 EnableSsl = configuration.UseSSL,
78.                 DeliveryMethod = SmtpDeliveryMethod.Network,
79.                 UseDefaultCredentials = configuration.UseDefaultCredentials,
80.                 Credentials = new NetworkCredential(
81. 					configuration.Email,
82. 					configuration.Password)
83.             };
84.             return smtpClient;
85. 		}
86. 	}
87. }
 
А.3 Код ORM класу для роботи з базою даних

1. using Microsoft.EntityFrameworkCore;
2. using SmartInlet.Server.Models;
3. 
4. namespace SmartInlet.Server.Services.DB
5. {
6.     /// <summary>
7.     /// ORM class to manage the database.
8.     /// </summary>
9.     public class DbApp : DbContext
10.     {
11.         public DbSet<ActivationCode> ActivationCodes { get; set; }
12.         public DbSet<AirSensor> AirSensors { get; set; }
13.         public DbSet<Group> Groups { get; set; }
14.         public DbSet<GroupMember> GroupMembers { get; set; }
15.         public DbSet<InletDevice> InletDevices { get; set; }
16.         public DbSet<JoinOffer> JoinOffers { get; set; }
17.         public DbSet<TempSensor> TempSensors { get; set; }
18.         public DbSet<User> Users { get; set; }
19. 
20.         public DbApp(DbContextOptions<DbApp> options) : base(options) { }
21. 
22.         protected override void OnModelCreating(ModelBuilder modelBuilder)
23.         {
24.             // column properties
25. 
26.             modelBuilder.Entity<User>()
27.                 .HasIndex(u => u.Username)
28.                 .IsUnique();
29. 
30.             modelBuilder.Entity<User>()
31.                 .HasIndex(u => u.Email)
32.                 .IsUnique();
33. 
34.             modelBuilder.Entity<Group>()
35.                 .HasIndex(o => o.Name)
36.                 .IsUnique();
37. 
38.             // 1-to-1 relationships
39. 
40.             modelBuilder.Entity<InletDevice>()
41.                 .HasOne(d => d.AirSensor)
42.                 .WithOne(vk => vk.InletDevice)
43.                 .HasForeignKey<AirSensor>(vk => vk.InletDeviceId)
44.                 .OnDelete(DeleteBehavior.Restrict);
45. 
46.             modelBuilder.Entity<AirSensor>()
47.                 .HasOne(vk => vk.InletDevice)
48.                 .WithOne(d => d.AirSensor)
49.                 .HasForeignKey<InletDevice>(d => d.AirSensorId)
50.                 .OnDelete(DeleteBehavior.Restrict);
51. 
52.             modelBuilder.Entity<InletDevice>()
53.                 .HasOne(d => d.TempSensor)
54.                 .WithOne(vk => vk.InletDevice)
55.                 .HasForeignKey<TempSensor>(vk => vk.InletDeviceId)
56.                 .OnDelete(DeleteBehavior.Restrict);
57. 
58.             modelBuilder.Entity<TempSensor>()
59.                 .HasOne(vk => vk.InletDevice)
60.                 .WithOne(d => d.TempSensor)
61.                 .HasForeignKey<InletDevice>(d => d.TempSensorId)
62.                 .OnDelete(DeleteBehavior.Restrict);
63. 
64.             // 1-to-many relationships
65. 
66.             modelBuilder.Entity<User>()
67.                 .HasMany(u => u.Groups)
68.                 .WithOne(o => o.Owner)
69.                 .HasForeignKey(o => o.OwnerId)
70.                 .OnDelete(DeleteBehavior.Restrict);
71. 
72.             modelBuilder.Entity<User>()
73.                 .HasMany(u => u.GroupMembers)
74.                 .WithOne(om => om.User)
75.                 .HasForeignKey(om => om.UserId)
76.                 .OnDelete(DeleteBehavior.Restrict);
77. 
78.             modelBuilder.Entity<User>()
79.                 .HasMany(u => u.ActivationCodes)
80.                 .WithOne(ac => ac.User)
81.                 .HasForeignKey(ac => ac.UserId)
82.                 .OnDelete(DeleteBehavior.Cascade);
83. 
84.             modelBuilder.Entity<User>()
85.                 .HasMany(o => o.JoinOffers)
86.                 .WithOne(ic => ic.User)
87.                 .HasForeignKey(ic => ic.UserId)
88.                 .OnDelete(DeleteBehavior.Restrict);
89. 
90.             modelBuilder.Entity<Group>()
91.                 .HasMany(g => g.GroupMembers)
92.                 .WithOne(m => m.Group)
93.                 .HasForeignKey(m => m.GroupId)
94.                 .OnDelete(DeleteBehavior.Cascade);
95. 
96.             modelBuilder.Entity<Group>()
97.                .HasMany(o => o.InletDevices)
98.                .WithOne(d => d.Group)
99.                .HasForeignKey(d => d.GroupId)
100.                .OnDelete(DeleteBehavior.Restrict);
101. 
102.             modelBuilder.Entity<Group>()
103.                .HasMany(o => o.AirSensors)
104.                .WithOne(d => d.Group)
105.                .HasForeignKey(d => d.GroupId)
106.                .OnDelete(DeleteBehavior.Restrict);
107. 
108.             modelBuilder.Entity<Group>()
109.                 .HasMany(o => o.JoinOffers)
110.                 .WithOne(ic => ic.Group)
111.                 .HasForeignKey(ic => ic.GroupId)
112.                 .OnDelete(DeleteBehavior.Restrict);
113. 
114.             base.OnModelCreating(modelBuilder);
115.         }
116.     }
117. }
 
А.4 Код класу з функціями для хешування та перевірки хешованих паролів.

1. using System.Security.Cryptography;
2. 
3. namespace SmartInlet.Server.Tools
4. {
5.     /// <summary>
6.     /// Implements a tool for working with passwords.
7.     /// </summary>
8.     public static class PasswordTool
9.     {
10.         public const int SaltByteSize = 32;
11.         public const int HashByteSize = 480;
12.         public const int HashingIterationsCount = 10210;
13. 
14.         /// <summary>
15.         /// Hashes a password by creating a password-based 
16.         /// key derivation function (PBKDF2).
17.         /// </summary>
18.         /// <param name="password">The password to hash.</param>
19.         /// <returns>The string that is the password-based key.</returns>
20.         public static string Hash(string password)
21.         {
22.             byte[] salt;
23.             new RNGCryptoServiceProvider()
24.                 .GetBytes(salt = new byte[SaltByteSize]);
25.             Rfc2898DeriveBytes? generator = new(
26.                 password,
27.                 salt,
28.                 HashingIterationsCount);
29.             byte[] hash = generator.GetBytes(HashByteSize);
30.             byte[] hashBytes = new byte[HashByteSize + SaltByteSize];
31. 
32.             Array.Copy(salt, 0, hashBytes, 0, SaltByteSize);
33.             Array.Copy(hash, 0, hashBytes, SaltByteSize, HashByteSize);
34. 
35.             return Convert.ToBase64String(hashBytes);
36.         }
37. 
38.         /// <summary>
39.         /// Checks if the two passwords match each 
40.         /// other where the second one is hashed.
41.         /// </summary>
42.         /// <param name="password">Non hashed password.</param>
43.         /// <param name="passwordHash">Hashed password.</param>
44.         /// <returns>True if the password is valid. Otherwise false.</returns>
45.         public static bool Validate(string password, string passwordHash)
46.         {
47.             try
48.             {
49.                 byte[] hashBytes = Convert.FromBase64String(passwordHash);
50. 
51.                 byte[] salt = new byte[SaltByteSize];
52.                 Array.Copy(hashBytes, 0, salt, 0, SaltByteSize);
53. 
54.                 Rfc2898DeriveBytes? generator = new(
55.                     password,
56.                     salt,
57.                     HashingIterationsCount);
58.                 byte[] hash = generator.GetBytes(HashByteSize);
59. 
60.                 for (int i = 0; i < HashByteSize; i++)
61.                 {
62.                     if (hashBytes[i + SaltByteSize] != hash[i])
63.                     {
64.                         return false;
65.                     }
66.                 }
67.             }
68.             catch
69.             {
70.                 return false;
71.             }
72. 
73.             return true;
74.         }
75.     }
76. }
 
А.5 Код контролеру для роботи з пристроями та датчиками

1. using Microsoft.AspNetCore.Mvc;
2. using Microsoft.EntityFrameworkCore;
3. using SmartInlet.Server.Attributes;
4. using SmartInlet.Server.Models;
5. using SmartInlet.Server.Requests;
6. using SmartInlet.Server.Responses;
7. using SmartInlet.Server.Services.DB;
8. using SmartInlet.Server.Tools;
9. using System.ComponentModel.DataAnnotations;
10. using System.Net;
11. 
12. namespace SmartInlet.Server.Controllers
13. {
14.     [ApiController]
15.     [Route("api/devices")]
16.     public class DeviceController : BaseController
17.     {
18.         public DeviceController(DbApp db) : base(db) { }
19. 
20.         [Authorized]
21.         [HttpPost]
22.         public async Task<IActionResult> AddDeviceToGroup(
23.             [FromBody] AccessDeviceRequest request)
24.         {
25.             Group? group = await DB.Groups
26.                 .SingleOrDefaultAsync(p => p.Name == request.GroupName);
27. 
28.             if (group == null)
29.             {
30.                 return NotFound(new BaseResponse.ErrorResponse(
31.                     "Group not found."));
32.             }
33. 
34.             GroupMember? member = await DB.GroupMembers
35.                 .SingleOrDefaultAsync(p => 
36.                 p.GroupId == group.Id &&
37.                 p.UserId == AuthorizedUserId);
38. 
39.             if (member == null)
40.             {
41.                 return NotFound(new BaseResponse.ErrorResponse(
42.                     "You are not a member of the group!"));
43.             }
44. 
45.             if (!member.CanEditDevices)
46.             {
47.                 return NotFound(new BaseResponse.ErrorResponse(
48.                     "You are not allowed to add devices!"));
49.             }
50. 
51.             switch (request.DeviceType)
52.             {
53.                 case "inlet":
54.                     InletDevice? device = await DB.InletDevices
55.                         .SingleOrDefaultAsync(p => p.Id == request.DeviceId);
56. 
57.                     if (device == null)
58.                     {
59.                         return NotFound(new BaseResponse.ErrorResponse(
60.                             "Device not found."));
61.                     }
62. 
63.                     if (device.IsBlocked)
64.                     {
65.                         return BadRequest(new BaseResponse.ErrorResponse(
66.                             "Device is blocked."));
67.                     }
68. 
69.                     if (!PasswordTool.Validate(request.AccessCode, device.AccessCode))
70.                     {
71.                         return BadRequest(new BaseResponse.ErrorResponse(
72.                             "Invalid access code."));
73.                     }
74. 
75.                     device.GroupId = group.Id;
76.                     device.Group = group;
77.                     break;
78.                 case "air":
79.                     AirSensor? airSensor = await DB.AirSensors
80.                         .SingleOrDefaultAsync(p => p.Id == request.DeviceId);
81. 
82.                     if (airSensor == null)
83.                     {
84.                         return NotFound(new BaseResponse.ErrorResponse(
85.                             "Device not found."));
86.                     }
87. 
88.                     if (airSensor.IsBlocked)
89.                     {
90.                         return BadRequest(new BaseResponse.ErrorResponse(
91.                             "Device is blocked."));
92.                     }
93. 
94.                     if (!PasswordTool.Validate(request.AccessCode, airSensor.AccessCode))
95.                     {
96.                         return BadRequest(new BaseResponse.ErrorResponse(
97.                             "Invalid access code."));
98.                     }
99. 
100.                     airSensor.GroupId = group.Id;
101.                     airSensor.Group = group;
102.                     break;
103.                 case "temp":
104.                     TempSensor? tempSensor = await DB.TempSensors
105.                         .SingleOrDefaultAsync(p => p.Id == request.DeviceId);
106. 
107.                     if (tempSensor == null)
108.                     {
109.                         return NotFound(new BaseResponse.ErrorResponse(
110.                             "Device not found."));
111.                     }
112. 
113.                     if (tempSensor.IsBlocked)
114.                     {
115.                         return BadRequest(new BaseResponse.ErrorResponse(
116.                             "Device is blocked."));
117.                     }
118. 
119.                     if (!PasswordTool.Validate(request.AccessCode, tempSensor.AccessCode))
120.                     {
121.                         return BadRequest(new BaseResponse.ErrorResponse(
122.                             "Invalid access code."));
123.                     }
124. 
125.                     tempSensor.GroupId = group.Id;
126.                     tempSensor.Group = group;
127.                     break;
128.                 default:
129.                     return BadRequest(new BaseResponse.ErrorResponse(
130.                         "Unknown device type."));
131.             }
132. 
133.             await DB.SaveChangesAsync();
134.             return Ok(new BaseResponse.SuccessResponse("Device added!"));
135.         }
136. 
137.         [Authorized]
138.         [HttpGet("inlet/by-group/{groupName}")]
139.         public async Task<IActionResult> GetInletDevices(
140.             [FromRoute] string groupName,
141.             [FromQuery] PageRequest pageRequest,
142.             [FromQuery] SearchDevicesRequest request)
143.         {
144.             Group? group = await DB.Groups
145.                 .SingleOrDefaultAsync(p => p.Name == WebUtility.UrlDecode(groupName));
146. 
147.             if (group == null)
148.             {
149.                 return NotFound(new BaseResponse.ErrorResponse("Group not found!"));
150.             }
151. 
152.             GroupMember? ownMember = await DB.GroupMembers
153.                 .SingleOrDefaultAsync(p => p.GroupId == group.Id && p.UserId == AuthorizedUserId);
154. 
155.             if (ownMember == null)
156.             {
157.                 return NotFound(new BaseResponse.ErrorResponse("You are not a member of the group!"));
158.             }
159. 
160.             request.Query = (request.Query ?? "").ToLower();
161.             IQueryable<InletDevice> query = DB.InletDevices
162.                 .Include(p => p.Group)
163.                 .Where(p => p.Group.Name == group.Name && p.Name.ToLower().Contains(request.Query))
164.                 .OrderBy(p => p.Group!.Name);
165. 
166.             int totalItemsCount = await query.CountAsync();
167.             int totalPagesCount = (int)Math.Ceiling((double)totalItemsCount / pageRequest.PageSize);
168.             query = query.Skip((pageRequest.Page - 1) * pageRequest.PageSize).Take(pageRequest.PageSize);
169.             List<InletDeviceResponse.View> result = await query
170.                 .Select(p => new InletDeviceResponse.View(p))
171.                 .ToListAsync();
172. 
173.             PageResponse<InletDeviceResponse.View> response = new(
174.                 result,
175.                 pageRequest.Page,
176.                 pageRequest.PageSize,
177.                 totalPagesCount);
178. 
179.             return Ok(response);
180.         }
181. 
182.         [Authorized]
183.         [HttpGet("air/by-group/{groupName}")]
184.         public async Task<IActionResult> GetAirSensors(
185.             [FromRoute] string groupName,
186.             [FromQuery] PageRequest pageRequest,
187.             [FromQuery] SearchDevicesRequest request)
188.         {
189.             Group? group = await DB.Groups
190.                 .SingleOrDefaultAsync(p => p.Name == WebUtility.UrlDecode(groupName));
191. 
192.             if (group == null)
193.             {
194.                 return NotFound(new BaseResponse.ErrorResponse("Group not found!"));
195.             }
196. 
197.             GroupMember? ownMember = await DB.GroupMembers
198.                 .SingleOrDefaultAsync(p => p.GroupId == group.Id && p.UserId == AuthorizedUserId);
199. 
200.             if (ownMember == null)
201.             {
202.                 return NotFound(new BaseResponse.ErrorResponse("You are not a member of the group!"));
203.             }
204. 
205.             request.Query = (request.Query ?? "").ToLower();
206.             IQueryable<AirSensor> query = DB.AirSensors
207.                 .Include(p => p.Group)
208.                 .Where(p => p.Group.Name == group.Name && p.Name.ToLower().Contains(request.Query))
209.                 .OrderBy(p => p.Group!.Name);
210. 
211.             int totalItemsCount = await query.CountAsync();
212.             int totalPagesCount = (int)Math.Ceiling((double)totalItemsCount / pageRequest.PageSize);
213.             query = query.Skip((pageRequest.Page - 1) * pageRequest.PageSize).Take(pageRequest.PageSize);
214.             List<AirSensorResponse.View> result = await query
215.                 .Select(p => new AirSensorResponse.View(p))
216.                 .ToListAsync();
217. 
218.             PageResponse<AirSensorResponse.View> response = new(
219.                 result,
220.                 pageRequest.Page,
221.                 pageRequest.PageSize,
222.                 totalPagesCount);
223. 
224.             return Ok(response);
225.         }
226. 
227.         [Authorized]
228.         [HttpGet("temp/by-group/{groupName}")]
229.         public async Task<IActionResult> GetTempSensors(
230.             [FromRoute] string groupName,
231.             [FromQuery] PageRequest pageRequest,
232.             [FromQuery] SearchDevicesRequest request)
233.         {
234.             Group? group = await DB.Groups
235.                 .SingleOrDefaultAsync(p => p.Name == WebUtility.UrlDecode(groupName));
236. 
237.             if (group == null)
238.             {
239.                 return NotFound(new BaseResponse.ErrorResponse("Group not found!"));
240.             }
241. 
242.             GroupMember? ownMember = await DB.GroupMembers
243.                 .SingleOrDefaultAsync(p => p.GroupId == group.Id && p.UserId == AuthorizedUserId);
244. 
245.             if (ownMember == null)
246.             {
247.                 return NotFound(new BaseResponse.ErrorResponse("You are not a member of the group!"));
248.             }
249. 
250.             request.Query = (request.Query ?? "").ToLower();
251.             IQueryable<TempSensor> query = DB.TempSensors
252.                 .Include(p => p.Group)
253.                 .Where(p => p.Group.Name == group.Name && p.Name.ToLower().Contains(request.Query))
254.                 .OrderBy(p => p.Group!.Name);
255. 
256.             int totalItemsCount = await query.CountAsync();
257.             int totalPagesCount = (int)Math.Ceiling((double)totalItemsCount / pageRequest.PageSize);
258.             query = query.Skip((pageRequest.Page - 1) * pageRequest.PageSize).Take(pageRequest.PageSize);
259.             List<TempSensorResponse.View> result = await query
260.                 .Select(p => new TempSensorResponse.View(p))
261.                 .ToListAsync();
262. 
263.             PageResponse<TempSensorResponse.View> response = new(
264.                 result,
265.                 pageRequest.Page,
266.                 pageRequest.PageSize,
267.                 totalPagesCount);
268. 
269.             return Ok(response);
270.         }
271. 
272.         [Authorized]
273.         [HttpPut("{deviceId}")]
274.         public async Task<IActionResult> RenameDevice(
275.             [FromRoute] int deviceId,
276.             [FromBody] RenameDeviceRequest request)
277.         {
278.             Group? group = await DB.Groups
279.                 .SingleOrDefaultAsync(p => p.Name == request.GroupName);
280. 
281.             if (group == null)
282.             {
283.                 return NotFound(new BaseResponse.ErrorResponse(
284.                     "Group not found."));
285.             }
286. 
287.             GroupMember? member = await DB.GroupMembers
288.                 .SingleOrDefaultAsync(
289.                 p => p.GroupId == group.Id &&
290.                 p.UserId == AuthorizedUserId);
291. 
292.             if (member == null)
293.             {
294.                 return NotFound(new BaseResponse.ErrorResponse(
295.                     "You are not a member of the group!"));
296.             }
297. 
298.             if (!member.CanEditDevices)
299.             {
300.                 return NotFound(new BaseResponse.ErrorResponse(
301.                     "You are not allowed to rename devices!"));
302.             }
303. 
304.             switch (request.DeviceType)
305.             {
306.                 case "inlet":
307.                     InletDevice? device = await DB.InletDevices
308.                         .SingleOrDefaultAsync(
309.                         p => p.Id == deviceId &&
310.                         p.GroupId == group.Id);
311. 
312.                     if (device == null)
313.                     {
314.                         return NotFound(new BaseResponse.ErrorResponse(
315.                             "Device not found."));
316.                     }
317. 
318.                     device.Name = request.DeviceName;
319.                     break;
320.                 case "air":
321.                     AirSensor? airSensor = await DB.AirSensors
322.                         .SingleOrDefaultAsync(
323.                         p => p.Id == deviceId &&
324.                         p.GroupId == group.Id);
325. 
326.                     if (airSensor == null)
327.                     {
328.                         return NotFound(new BaseResponse.ErrorResponse(
329.                             "Device not found."));
330.                     }
331. 
332.                     airSensor.Name = request.DeviceName;
333.                     break;
334.                 case "temp":
335.                     TempSensor? tempSensor = await DB.TempSensors
336.                         .SingleOrDefaultAsync(
337.                         p => p.Id == deviceId
338.                         && p.GroupId == group.Id);
339. 
340.                     if (tempSensor == null)
341.                     {
342.                         return NotFound(new BaseResponse.ErrorResponse(
343.                             "Device not found."));
344.                     }
345. 
346.                     tempSensor.Name = request.DeviceName;
347.                     break;
348.                 default:
349.                     return BadRequest(new BaseResponse.ErrorResponse(
350.                         "Unknown device type."));
351.             }
352. 
353.             await DB.SaveChangesAsync();
354.             return Ok(new BaseResponse.SuccessResponse(
355.                 "Device renamed!"));
356.         }
357. 
358.         [Authorized]
359.         [HttpPut("inlet/{deviceId}/open")]
360.         public async Task<IActionResult> OpenInletDevice(
361.             [FromRoute] int deviceId,
362.             [Required][FromBody] string groupName)
363.         {
364.             Group? group = await DB.Groups
365.                 .SingleOrDefaultAsync(p => p.Name == groupName);
366. 
367.             if (group == null)
368.             {
369.                 return NotFound(new BaseResponse.ErrorResponse(
370.                     "Group not found."));
371.             }
372. 
373.             GroupMember? member = await DB.GroupMembers
374.                 .SingleOrDefaultAsync(
375.                 p => p.GroupId == group.Id &&
376.                 p.UserId == AuthorizedUserId);
377. 
378.             if (member == null)
379.             {
380.                 return NotFound(new BaseResponse.ErrorResponse(
381.                     "You are not a member of the group!"));
382.             }
383. 
384.             if (!member.CanEditDevices)
385.             {
386.                 return NotFound(new BaseResponse.ErrorResponse(
387.                     "You are not allowed to rename devices!"));
388.             }
389. 
390.             InletDevice? device = await DB.InletDevices
391.                 .SingleOrDefaultAsync(
392.                 p => p.Id == deviceId &&
393.                 p.GroupId == group.Id);
394. 
395.             if (device == null)
396.             {
397.                 return NotFound(new BaseResponse.ErrorResponse(
398.                     "Device not found."));
399.             }
400. 
401.             if (device.ControlType != "manual")
402.             {
403.                 return BadRequest(new BaseResponse.ErrorResponse(
404.                     "Device is not controlled manually."));
405.             }
406. 
407.             device.IsOpened = !device.IsOpened;
408.             await DB.SaveChangesAsync();
409.             return Ok(new BaseResponse.SuccessResponse(
410.                 "Device opened!"));
411.         }
412. 
413.         [Authorized]
414.         [HttpPut("inlet/{deviceId}/control-type/manual")]
415.         public async Task<IActionResult> ChangeDeviceControlTypeToManual(
416.             [FromRoute] int deviceId,
417.             [Required][FromBody] string groupName)
418.         {
419.             Group? group = await DB.Groups
420.                 .SingleOrDefaultAsync(p => p.Name == groupName);
421. 
422.             if (group == null)
423.             {
424.                 return NotFound(new BaseResponse.ErrorResponse(
425.                     "Group not found."));
426.             }
427. 
428.             GroupMember? member = await DB.GroupMembers
429.                 .SingleOrDefaultAsync(
430.                 p => p.GroupId == group.Id &&
431.                 p.UserId == AuthorizedUserId);
432. 
433.             if (member == null)
434.             {
435.                 return NotFound(new BaseResponse.ErrorResponse(
436.                     "You are not a member of the group!"));
437.             }
438. 
439.             if (!member.CanEditDevices)
440.             {
441.                 return NotFound(new BaseResponse.ErrorResponse(
442.                     "You are not allowed to rename devices!"));
443.             }
444. 
445.             InletDevice? device = await DB.InletDevices
446.                 .Include(p => p.AirSensor)
447.                 .SingleOrDefaultAsync(
448.                 p => p.Id == deviceId &&
449.                 p.GroupId == group.Id);
450. 
451.             if (device == null)
452.             {
453.                 return NotFound(new BaseResponse.ErrorResponse(
454.                     "Device not found."));
455.             }
456. 
457.             if (device.ControlType == "air")
458.             {
459.                 AirSensor? sensor = device.AirSensor;
460.                 if (sensor != null)
461.                 {
462.                     sensor.InletDevice = null;
463.                     sensor.InletDeviceId = null;
464.                 }
465. 
466.                 device.AirSensor = null;
467.                 device.AirSensorId = null;
468.             } else if (device.ControlType == "temp")
469.             {
470.                 TempSensor? sensor = device.TempSensor;
471.                 if (sensor != null)
472.                 {
473.                     sensor.InletDevice = null;
474.                     sensor.InletDeviceId = null;
475.                 }
476. 
477.                 device.TempSensor = null;
478.                 device.TempSensorId = null;
479.             }
480. 
481.             device.ControlType = "manual";
482. 
483.             await DB.SaveChangesAsync();
484.             return Ok(new BaseResponse.SuccessResponse(
485.                 "Device control type changed."));
486.         }
487. 
488.         [Authorized]
489.         [HttpPut("inlet/{deviceId}/control-type/air")]
490.         public async Task<IActionResult> ChangeDeviceControlTypeToAir(
491.             [FromRoute] int deviceId,
492.             [FromBody] ChangeSensorRequest request)
493.         {
494.             Group? group = await DB.Groups
495.                 .SingleOrDefaultAsync(p => p.Name == request.GroupName);
496. 
497.             if (group == null)
498.             {
499.                 return NotFound(new BaseResponse.ErrorResponse(
500.                     "Group not found."));
501.             }
502. 
503.             GroupMember? member = await DB.GroupMembers
504.                 .SingleOrDefaultAsync(
505.                 p => p.GroupId == group.Id &&
506.                 p.UserId == AuthorizedUserId);
507. 
508.             if (member == null)
509.             {
510.                 return NotFound(new BaseResponse.ErrorResponse(
511.                     "You are not a member of the group!"));
512.             }
513. 
514.             if (!member.CanEditDevices)
515.             {
516.                 return NotFound(new BaseResponse.ErrorResponse(
517.                     "You are not allowed to rename devices!"));
518.             }
519. 
520.             InletDevice? device = await DB.InletDevices
521.                         .SingleOrDefaultAsync(
522.                 p => p.Id == deviceId &&
523.                 p.GroupId == group.Id);
524. 
525.             if (device == null)
526.             {
527.                 return NotFound(new BaseResponse.ErrorResponse(
528.                     "Device not found."));
529.             }
530. 
531.             AirSensor? sensor = await DB.AirSensors
532.                 .SingleOrDefaultAsync(
533.                 p => p.Id == request.SensorId &&
534.                 p.GroupId == group.Id);
535. 
536.             if (sensor == null)
537.             {
538.                 return NotFound(new BaseResponse.ErrorResponse(
539.                     "Sensor not found."));
540.             }
541. 
542.             if (device.ControlType == "temp")
543.             {
544.                 TempSensor? ts = device.TempSensor;
545. 
546.                 if (ts == null)
547.                 {
548.                     return NotFound(new BaseResponse.ErrorResponse(
549.                         "Temperature sensor not found."));
550.                 }
551. 
552.                 ts.InletDeviceId = null;
553.                 ts.InletDevice = null;
554.                 device.TempSensorId = null;
555.                 device.TempSensor = null;
556.             }
557. 
558.             sensor.InletDeviceId = device.Id;
559.             sensor.InletDevice = device;
560.             device.AirSensorId = sensor.Id;
561.             device.AirSensor = sensor;
562.             device.ControlType = "air";
563. 
564.             await DB.SaveChangesAsync();
565.             return Ok(new BaseResponse.SuccessResponse(
566.                 "Device control type changed."));
567.         }
568. 
569.         [Authorized]
570.         [HttpPut("inlet/{deviceId}/control-type/temp")]
571.         public async Task<IActionResult> ChangeDeviceControlTypeToTemp(
572.             [FromRoute] int deviceId,
573.             [FromBody] ChangeSensorRequest request)
574.         {
575.             Group? group = await DB.Groups
576.                 .SingleOrDefaultAsync(p => p.Name == request.GroupName);
577. 
578.             if (group == null)
579.             {
580.                 return NotFound(new BaseResponse.ErrorResponse(
581.                     "Group not found."));
582.             }
583. 
584.             GroupMember? member = await DB.GroupMembers
585.                 .SingleOrDefaultAsync(
586.                 p => p.GroupId == group.Id &&
587.                 p.UserId == AuthorizedUserId);
588. 
589.             if (member == null)
590.             {
591.                 return NotFound(new BaseResponse.ErrorResponse(
592.                     "You are not a member of the group!"));
593.             }
594. 
595.             if (!member.CanEditDevices)
596.             {
597.                 return NotFound(new BaseResponse.ErrorResponse(
598.                     "You are not allowed to rename devices!"));
599.             }
600. 
601.             InletDevice? device = await DB.InletDevices
602.                         .SingleOrDefaultAsync(
603.                 p => p.Id == deviceId &&
604.                 p.GroupId == group.Id);
605. 
606.             if (device == null)
607.             {
608.                 return NotFound(new BaseResponse.ErrorResponse(
609.                     "Device not found."));
610.             }
611. 
612.             TempSensor? sensor = await DB.TempSensors
613.                 .SingleOrDefaultAsync(
614.                 p => p.Id == request.SensorId &&
615.                 p.GroupId == group.Id);
616. 
617.             if (sensor == null)
618.             {
619.                 return NotFound(new BaseResponse.ErrorResponse(
620.                     "Sensor not found."));
621.             }
622. 
623.             if (device.ControlType == "air")
624.             {
625.                 AirSensor? @as = device.AirSensor;
626. 
627.                 if (@as == null)
628.                 {
629.                     return NotFound(new BaseResponse.ErrorResponse(
630.                         "Air sensor not found."));
631.                 }
632. 
633.                 @as.InletDeviceId = null;
634.                 @as.InletDevice = null;
635.                 device.AirSensorId = null;
636.                 device.AirSensor = null;
637.             }
638. 
639.             sensor.InletDeviceId = device.Id;
640.             sensor.InletDevice = device;
641.             device.TempSensorId = sensor.Id;
642.             device.TempSensor = sensor;
643.             device.ControlType = "temp";
644. 
645.             await DB.SaveChangesAsync();
646.             return Ok(new BaseResponse.SuccessResponse(
647.                 "Device control type changed."));
648.         }
649. 
650.         [Authorized]
651.         [HttpPut("inlet/{deviceId}/air-sensor")]
652.         public async Task<IActionResult> ChangeAirSensorForDevice(
653.             [FromRoute] int deviceId,
654.             [FromBody] ChangeSensorRequest request)
655.         {
656.             Group? group = await DB.Groups
657.                 .SingleOrDefaultAsync(p => p.Name == request.GroupName);
658. 
659.             if (group == null)
660.             {
661.                 return NotFound(new BaseResponse.ErrorResponse(
662.                     "Group not found."));
663.             }
664. 
665.             GroupMember? member = await DB.GroupMembers
666.                 .SingleOrDefaultAsync(
667.                 p => p.GroupId == group.Id &&
668.                 p.UserId == AuthorizedUserId);
669. 
670.             if (member == null)
671.             {
672.                 return NotFound(new BaseResponse.ErrorResponse(
673.                     "You are not a member of the group!"));
674.             }
675. 
676.             if (!member.CanEditDevices)
677.             {
678.                 return NotFound(new BaseResponse.ErrorResponse(
679.                     "You are not allowed to rename devices!"));
680.             }
681. 
682.             InletDevice? device = await DB.InletDevices
683.                 .Include(p => p.AirSensor)
684.                 .SingleOrDefaultAsync(
685.                 p => p.Id == deviceId &&
686.                 p.GroupId == group.Id);
687. 
688.             if (device == null)
689.             {
690.                 return NotFound(new BaseResponse.ErrorResponse(
691.                     "Device not found."));
692.             }
693. 
694.             if (device.ControlType != "air")
695.             {
696.                 return NotFound(new BaseResponse.ErrorResponse(
697.                     "Device is not controlled by an air sensor."));
698.             }
699. 
700.             AirSensor? oldSensor = device.AirSensor;
701. 
702.             if (oldSensor == null)
703.             {
704.                 return NotFound(new BaseResponse.ErrorResponse(
705.                     "Old sensor not found."));
706.             }
707. 
708.             AirSensor? sensor = await DB.AirSensors
709.                 .SingleOrDefaultAsync(
710.                 p => p.Id == request.SensorId &&
711.                 p.GroupId == group.Id);
712. 
713.             if (sensor == null)
714.             {
715.                 return NotFound(new BaseResponse.ErrorResponse(
716.                     "Sensor not found."));
717.             }
718. 
719.             oldSensor.InletDeviceId = null;
720.             oldSensor.InletDevice = null;
721.             sensor.InletDeviceId = device.Id;
722.             sensor.InletDevice = device;
723.             device.AirSensorId = sensor.Id;
724.             device.AirSensor = sensor;
725. 
726.             await DB.SaveChangesAsync();
727.             return Ok(new BaseResponse.SuccessResponse(
728.                 "Air sensor for the device is changed."));
729.         }
730. 
731.         [Authorized]
732.         [HttpPut("inlet/{deviceId}/temp-sensor")]
733.         public async Task<IActionResult> ChangeTempSensorForDevice(
734.             [FromRoute] int deviceId,
735.             [FromBody] ChangeSensorRequest request)
736.         {
737.             Group? group = await DB.Groups
738.                 .SingleOrDefaultAsync(p => p.Name == request.GroupName);
739. 
740.             if (group == null)
741.             {
742.                 return NotFound(new BaseResponse.ErrorResponse(
743.                     "Group not found."));
744.             }
745. 
746.             GroupMember? member = await DB.GroupMembers
747.                 .SingleOrDefaultAsync(
748.                 p => p.GroupId == group.Id &&
749.                 p.UserId == AuthorizedUserId);
750. 
751.             if (member == null)
752.             {
753.                 return NotFound(new BaseResponse.ErrorResponse(
754.                     "You are not a member of the group!"));
755.             }
756. 
757.             if (!member.CanEditDevices)
758.             {
759.                 return NotFound(new BaseResponse.ErrorResponse(
760.                     "You are not allowed to rename devices!"));
761.             }
762. 
763.             InletDevice? device = await DB.InletDevices
764.                 .Include(p => p.TempSensor)
765.                 .SingleOrDefaultAsync(
766.                 p => p.Id == deviceId &&
767.                 p.GroupId == group.Id);
768. 
769.             if (device == null)
770.             {
771.                 return NotFound(new BaseResponse.ErrorResponse(
772.                     "Device not found."));
773.             }
774. 
775.             if (device.ControlType != "temp")
776.             {
777.                 return NotFound(new BaseResponse.ErrorResponse(
778.                     "Device is not controlled by an temperature sensor."));
779.             }
780. 
781.             TempSensor? oldSensor = device.TempSensor;
782. 
783.             if (oldSensor == null)
784.             {
785.                 return NotFound(new BaseResponse.ErrorResponse(
786.                     "Old sensor not found."));
787.             }
788. 
789.             TempSensor? sensor = await DB.TempSensors
790.                 .SingleOrDefaultAsync(
791.                 p => p.Id == request.SensorId &&
792.                 p.GroupId == group.Id);
793. 
794.             if (sensor == null)
795.             {
796.                 return NotFound(new BaseResponse.ErrorResponse(
797.                     "Sensor not found."));
798.             }
799. 
800.             oldSensor.InletDeviceId = null;
801.             oldSensor.InletDevice = null;
802.             sensor.InletDeviceId = device.Id;
803.             sensor.InletDevice = device;
804.             device.TempSensorId = sensor.Id;
805.             device.TempSensor = sensor;
806. 
807.             await DB.SaveChangesAsync();
808.             return Ok(new BaseResponse.SuccessResponse(
809.                 "Temperature sensor for the device is changed."));
810.         }
811. 
812.         [Authorized]
813.         [HttpPut("air/{sensorId}/limits")]
814.         public async Task<IActionResult> ChangeAirSensorLimits(
815.             [FromRoute] int sensorId,
816.             [FromBody] ChangeSensorLimitsRequest request)
817.         {
818.             if (request.ToOpen <= request.ToClose)
819.             {
820.                 return BadRequest(new BaseResponse.ErrorResponse(
821.                     "To-open limit must be higher than to-close one."));
822.             }
823. 
824.             Group? group = await DB.Groups
825.                 .SingleOrDefaultAsync(p => p.Name == request.GroupName);
826. 
827.             if (group == null)
828.             {
829.                 return NotFound(new BaseResponse.ErrorResponse(
830.                     "Group not found."));
831.             }
832. 
833.             GroupMember? member = await DB.GroupMembers
834.                 .SingleOrDefaultAsync(
835.                 p => p.GroupId == group.Id &&
836.                 p.UserId == AuthorizedUserId);
837. 
838.             if (member == null)
839.             {
840.                 return NotFound(new BaseResponse.ErrorResponse(
841.                     "You are not a member of the group!"));
842.             }
843. 
844.             if (!member.CanEditDevices)
845.             {
846.                 return NotFound(new BaseResponse.ErrorResponse(
847.                     "You are not allowed to rename devices!"));
848.             }
849. 
850.             AirSensor? sensor = await DB.AirSensors
851.                 .SingleOrDefaultAsync(
852.                 p => p.Id == sensorId &&
853.                 p.GroupId == group.Id);
854. 
855.             if (sensor == null)
856.             {
857.                 return NotFound(new BaseResponse.ErrorResponse(
858.                     "Sensor not found."));
859.             }
860. 
861.             sensor.AqiLimitToOpen = request.ToOpen;
862.             sensor.AqiLimitToClose = request.ToClose;
863. 
864.             await DB.SaveChangesAsync();
865.             return Ok(new AirSensorResponse(sensor));
866.         }
867. 
868.         [Authorized]
869.         [HttpPut("temp/{sensorId}/limits")]
870.         public async Task<IActionResult> ChangeTempSensorLimits(
871.             [FromRoute] int sensorId,
872.             [FromBody] ChangeSensorLimitsRequest request)
873.         {
874.             if (request.ToOpen <= request.ToClose)
875.             {
876.                 return BadRequest(new BaseResponse.ErrorResponse(
877.                     "To-open limit must be higher than to-close one."));
878.             }
879. 
880.             Group? group = await DB.Groups
881.                 .SingleOrDefaultAsync(p => p.Name == request.GroupName);
882. 
883.             if (group == null)
884.             {
885.                 return NotFound(new BaseResponse.ErrorResponse(
886.                     "Group not found."));
887.             }
888. 
889.             GroupMember? member = await DB.GroupMembers
890.                 .SingleOrDefaultAsync(
891.                 p => p.GroupId == group.Id &&
892.                 p.UserId == AuthorizedUserId);
893. 
894.             if (member == null)
895.             {
896.                 return NotFound(new BaseResponse.ErrorResponse(
897.                     "You are not a member of the group!"));
898.             }
899. 
900.             if (!member.CanEditDevices)
901.             {
902.                 return NotFound(new BaseResponse.ErrorResponse(
903.                     "You are not allowed to rename devices!"));
904.             }
905. 
906.             TempSensor? sensor = await DB.TempSensors
907.                 .SingleOrDefaultAsync(
908.                 p => p.Id == sensorId &&
909.                 p.GroupId == group.Id);
910. 
911.             if (sensor == null)
912.             {
913.                 return NotFound(new BaseResponse.ErrorResponse(
914.                     "Sensor not found."));
915.             }
916. 
917.             sensor.KelvinLimitToOpen = request.ToOpen;
918.             sensor.KelvinLimitToClose = request.ToClose;
919. 
920.             await DB.SaveChangesAsync();
921.             return Ok(new TempSensorResponse(sensor));
922.         }
923. 
924.         [Authorized]
925.         [HttpDelete("{deviceId}")]
926.         public async Task<IActionResult> DeleteDevice(
927.             [FromRoute] int deviceId,
928.             [FromQuery] string groupName,
929.             [FromQuery] string deviceType)
930.         {
931.             Group? group = await DB.Groups
932.                 .SingleOrDefaultAsync(
933.                 p => p.Name == WebUtility.UrlEncode(groupName));
934. 
935.             if (group == null)
936.             {
937.                 return NotFound(new BaseResponse.ErrorResponse(
938.                     "Group not found."));
939.             }
940. 
941.             GroupMember? member = await DB.GroupMembers
942.                 .SingleOrDefaultAsync(
943.                 p => p.GroupId == group.Id &&
944.                 p.UserId == AuthorizedUserId);
945. 
946.             if (member == null)
947.             {
948.                 return NotFound(new BaseResponse.ErrorResponse(
949.                     "You are not a member of the group!"));
950.             }
951. 
952.             if (!member.CanEditDevices)
953.             {
954.                 return NotFound(new BaseResponse.ErrorResponse(
955.                     "You are not allowed to rename devices!"));
956.             }
957. 
958.             switch (deviceType)
959.             {
960.                 case "inlet":
961.                     InletDevice? device = await DB.InletDevices
962.                         .SingleOrDefaultAsync(
963.                         p => p.Id == deviceId &&
964.                         p.GroupId == group.Id);
965. 
966.                     if (device == null)
967.                     {
968.                         return NotFound(new BaseResponse.ErrorResponse(
969.                             "Device not found."));
970.                     }
971. 
972.                     device.GroupId = null;
973.                     device.Group = null;
974.                     device.AirSensorId = null;
975.                     device.AirSensor = null;
976.                     device.TempSensorId = null;
977.                     device.TempSensor = null;
978.                     device.ControlType = "manual";
979.                     break;
980.                 case "air":
981.                     AirSensor? airSensor = await DB.AirSensors
982.                         .SingleOrDefaultAsync(
983.                         p => p.Id == deviceId &&
984.                         p.GroupId == group.Id);
985. 
986.                     if (airSensor == null)
987.                     {
988.                         return NotFound(new BaseResponse.ErrorResponse(
989.                             "Device not found."));
990.                     }
991. 
992.                     airSensor.GroupId = null;
993.                     airSensor.Group = null;
994.                     airSensor.InletDeviceId = null;
995.                     airSensor.InletDevice = null;
996.                     break;
997.                 case "temp":
998.                     TempSensor? tempSensor = await DB.TempSensors
999.                         .SingleOrDefaultAsync(
1000.                         p => p.Id == deviceId &&
1001.                         p.GroupId == group.Id);
1002. 
1003.                     if (tempSensor == null)
1004.                     {
1005.                         return NotFound(new BaseResponse.ErrorResponse(
1006.                             "Device not found."));
1007.                     }
1008. 
1009.                     tempSensor.GroupId = null;
1010.                     tempSensor.Group = null;
1011.                     tempSensor.InletDeviceId = null;
1012.                     tempSensor.InletDevice = null;
1013.                     break;
1014.                 default:
1015.                     return BadRequest(new BaseResponse.ErrorResponse(
1016.                         "Unknown device type."));
1017.             }
1018. 
1019.             await DB.SaveChangesAsync();
1020.             return Ok(new BaseResponse.SuccessResponse("Device renamed!"));
1021.         }
1022.     }
1023. }
 
ДОДАТОК Б
Результат перевірки на плагіат